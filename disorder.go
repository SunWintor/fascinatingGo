package main

import (
	"fmt"
	"sync"
)

// https://golang.google.cn/ref/mem
// 使用golang验证cpu的指令重排序情况。
// 指令重排序：
//     解释：编译器和处理器可能会对指令进行重排，简单的说就是，当存在依赖关系的时候，代码是顺序执行的
//         但是不存在依赖关系的时候，代码就可以按照任意顺序执行了。
//     例如：a = 1; b = 2; 先执行a = 1还是先执行b = 2不会影响程序执行的结果，此时就可能发生指令重排序的情况。
//     原因：指令重排序可以提升执行效率。现在的CPU一般采用流水线来执行指令。一个指令的执行被分成：取指、译码、访存、执行、写回、等若干个阶段。
//         在流水线工作时，相比串行的A->B->C->D->E这样的执行，显然不如在一条流水线上ABCDE同时在执行效率高。
//         cpu在执行的时候，会将所有指令打乱，此时就可能会乱序执行。（多核心协同处理，自动优化和重排指令顺序）
//         不光cpu会进行指令重排序，编译器也会对代码顺序进行重排，优先进行读操作
//         （缓存中有一些共享数据，优先读操作，避免写操作破坏了读操作的缓存，导致缓存重新加载）
//     什么情况不会指令重排序？：对同一个变量，写后读、读后写、写后写。
func main() {
	for true {
		for runTimes := 0; true; runTimes++ {
			x, y, a, b := 0, 0, 0, 0
			var wg sync.WaitGroup
			wg.Add(2)
			go func() {
				defer wg.Done()
				a = 1
				x = b
			}()
			go func() {
				defer wg.Done()
				b = 1
				y = a
			}()
			wg.Wait()
			// 在这个位置，无论是a = 1先执行还是b = 1先执行，都不可能出现x和y同时为0的情况
			// 如果出现了x和y同时为0的情况，说明程序先执行了x = b，然后执行了y = a，再执行了a = 1和b = 1
			if x == 0 && y == 0 {
				println(fmt.Sprintf("第%+v次执行，发现x和y同时为0", runTimes))
				return
			}
		}
	}
}
