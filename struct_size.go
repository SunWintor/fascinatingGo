package main

import "unsafe"

func main() {
	// 内存与cpu通信时，使用的是总线进行通信。
	// cpu通过地址总线，向内存索取内存值，内存通过数据总线返回数据。假设总线是64根，那就可以一次操作64bit，也就是8byte的数据。
	// 我们看到的内存条上的黑色颗粒，一般一面是有八个，这八个名字叫做chip。
	// 在我们读取内存的一个地址时，实际上是从这八个chip中的同一个地址上，各取一个字节出来，把它们拼在一起，组成一个8byte的数据。
	// 那么问题来了，如果我要取的数据跨了两个区域，那必然要读取两次，这样就要对性能有大量的消耗。
	// 所以golang做了内存对齐。
	// 简单的说就是，如果你占用4byte，那么你就只能从4的整数位置开始。如果你占用8byte，那么你就只能从8的整数位置开始。
	// 就算中间是有空缺的，那么也不能存储数据，因为可能会串开后面数据的存储，带来性能损耗。
	// 详见本文件的Test1和Test2结构体。
	a := Test1{}
	b := Test2{}
	println(unsafe.Sizeof(a)) // 24
	println(unsafe.Sizeof(b)) // 16

	println("========================================")
	// 题外话，golang的string类型固定占用16字节的空间。
	// 这和其内部结构有关，golang的string类型内部有一个指向实际存放字符串位置的指针，还有一个代表长度的int型变量。
	// 指针和int都是8字节，所以固定占用16字节空间。（注意，int也可能占用4字节，这和代码运行在什么平台有关）
	println(unsafe.Sizeof("这是一个超级长的字符串，但是这里的输出只会是16。")) // 16
	println(unsafe.Sizeof("这也16")) // 16
	println(unsafe.Sizeof("")) // 16
	// 题外话题外话
	println(unsafe.Sizeof(struct{}{})) // 0
}

// byte占用情况（假设一个数字就是一个byte）
// 11100000 11111111 10110000
type Test1 struct {
	a int32 // 一共4byte，占用第0到3字节
	b int64 // 一共8byte，占用第8到15个字节
	c int8  // 一共1byte，占用第16个字节
	d int16 // 一共2byte，占用第18、19个字节
	// 一共20个字节，不满8的倍数，必须补齐到8的倍数，也就是24。
}

// byte占用情况（假设一个数字就是一个byte）
// 10111111 11111111
type Test2 struct {
	a int8  // 一共1byte，占用第0个字节
	b int16 // 一共2byte，占用第2、3个字节
	c int32 // 一共4byte，占用第4到7个字节
	d int64 // 一共8byte，占用第8到15个字节
	// 一共16个字节，满8的倍数，不必补齐。
}
